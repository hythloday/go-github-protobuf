// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gist_event.proto

package github

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GistFile struct {
	FileSize  int32  `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	RawUrl    string `protobuf:"bytes,2,opt,name=raw_url,json=rawUrl,proto3" json:"raw_url,omitempty"`
	Type      string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Language  string `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	Truncated bool   `protobuf:"varint,5,opt,name=truncated,proto3" json:"truncated,omitempty"`
	Content   string `protobuf:"bytes,6,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *GistFile) Reset()                    { *m = GistFile{} }
func (m *GistFile) String() string            { return proto.CompactTextString(m) }
func (*GistFile) ProtoMessage()               {}
func (*GistFile) Descriptor() ([]byte, []int) { return fileDescriptorGistEvent, []int{0} }

type GistFork struct {
	User      *User  `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	Url       string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	Id        string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	CreatedAt string `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt string `protobuf:"bytes,5,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (m *GistFork) Reset()                    { *m = GistFork{} }
func (m *GistFork) String() string            { return proto.CompactTextString(m) }
func (*GistFork) ProtoMessage()               {}
func (*GistFork) Descriptor() ([]byte, []int) { return fileDescriptorGistEvent, []int{1} }

type GistChangeStatus struct {
	Deletions int32 `protobuf:"varint,1,opt,name=deletions,proto3" json:"deletions,omitempty"`
	Additions int32 `protobuf:"varint,2,opt,name=additions,proto3" json:"additions,omitempty"`
	Total     int32 `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
}

func (m *GistChangeStatus) Reset()                    { *m = GistChangeStatus{} }
func (m *GistChangeStatus) String() string            { return proto.CompactTextString(m) }
func (*GistChangeStatus) ProtoMessage()               {}
func (*GistChangeStatus) Descriptor() ([]byte, []int) { return fileDescriptorGistEvent, []int{2} }

type GistHistory struct {
	Url          string            `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Version      string            `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	User         *User             `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	ChangeStatus *GistChangeStatus `protobuf:"bytes,4,opt,name=change_status,json=changeStatus" json:"change_status,omitempty"`
	CommittedAt  string            `protobuf:"bytes,5,opt,name=committed_at,json=committedAt,proto3" json:"committed_at,omitempty"`
}

func (m *GistHistory) Reset()                    { *m = GistHistory{} }
func (m *GistHistory) String() string            { return proto.CompactTextString(m) }
func (*GistHistory) ProtoMessage()               {}
func (*GistHistory) Descriptor() ([]byte, []int) { return fileDescriptorGistEvent, []int{3} }

type Gist struct {
	Url         string               `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	ForksUrl    string               `protobuf:"bytes,2,opt,name=forks_url,json=forksUrl,proto3" json:"forks_url,omitempty"`
	CommitsUrl  string               `protobuf:"bytes,3,opt,name=commits_url,json=commitsUrl,proto3" json:"commits_url,omitempty"`
	Id          int32                `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	Description string               `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Public      bool                 `protobuf:"varint,6,opt,name=public,proto3" json:"public,omitempty"`
	Owner       *User                `protobuf:"bytes,7,opt,name=owner" json:"owner,omitempty"`
	User        *User                `protobuf:"bytes,8,opt,name=user" json:"user,omitempty"`
	Files       map[string]*GistFile `protobuf:"bytes,9,rep,name=files" json:"files,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Truncated   bool                 `protobuf:"varint,10,opt,name=truncated,proto3" json:"truncated,omitempty"`
	Comments    int32                `protobuf:"varint,11,opt,name=comments,proto3" json:"comments,omitempty"`
	CommentsUrl string               `protobuf:"bytes,12,opt,name=comments_url,json=commentsUrl,proto3" json:"comments_url,omitempty"`
	HtmlUrl     string               `protobuf:"bytes,13,opt,name=html_url,json=htmlUrl,proto3" json:"html_url,omitempty"`
	GitPullUrl  string               `protobuf:"bytes,14,opt,name=git_pull_url,json=gitPullUrl,proto3" json:"git_pull_url,omitempty"`
	GitPushUrl  string               `protobuf:"bytes,15,opt,name=git_push_url,json=gitPushUrl,proto3" json:"git_push_url,omitempty"`
	CreatedAt   string               `protobuf:"bytes,16,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt   string               `protobuf:"bytes,17,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	Forks       []*GistFork          `protobuf:"bytes,18,rep,name=forks" json:"forks,omitempty"`
}

func (m *Gist) Reset()                    { *m = Gist{} }
func (m *Gist) String() string            { return proto.CompactTextString(m) }
func (*Gist) ProtoMessage()               {}
func (*Gist) Descriptor() ([]byte, []int) { return fileDescriptorGistEvent, []int{4} }

type GistEvent struct {
	Action       string        `protobuf:"bytes,1,opt,name=action,proto3" json:"action,omitempty"`
	Gist         *Gist         `protobuf:"bytes,2,opt,name=gist" json:"gist,omitempty"`
	Installation *Installation `protobuf:"bytes,3,opt,name=installation" json:"installation,omitempty"`
}

func (m *GistEvent) Reset()                    { *m = GistEvent{} }
func (m *GistEvent) String() string            { return proto.CompactTextString(m) }
func (*GistEvent) ProtoMessage()               {}
func (*GistEvent) Descriptor() ([]byte, []int) { return fileDescriptorGistEvent, []int{5} }

func init() {
	proto.RegisterType((*GistFile)(nil), "github.GistFile")
	proto.RegisterType((*GistFork)(nil), "github.GistFork")
	proto.RegisterType((*GistChangeStatus)(nil), "github.GistChangeStatus")
	proto.RegisterType((*GistHistory)(nil), "github.GistHistory")
	proto.RegisterType((*Gist)(nil), "github.Gist")
	proto.RegisterType((*GistEvent)(nil), "github.GistEvent")
}
func (m *GistFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GistFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FileSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.FileSize))
	}
	if len(m.RawUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.RawUrl)))
		i += copy(dAtA[i:], m.RawUrl)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if m.Truncated {
		dAtA[i] = 0x28
		i++
		if m.Truncated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *GistFork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GistFork) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.User.Size()))
		n1, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.CreatedAt) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.CreatedAt)))
		i += copy(dAtA[i:], m.CreatedAt)
	}
	if len(m.UpdatedAt) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.UpdatedAt)))
		i += copy(dAtA[i:], m.UpdatedAt)
	}
	return i, nil
}

func (m *GistChangeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GistChangeStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Deletions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.Deletions))
	}
	if m.Additions != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.Additions))
	}
	if m.Total != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.Total))
	}
	return i, nil
}

func (m *GistHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GistHistory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.User != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.User.Size()))
		n2, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.ChangeStatus != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.ChangeStatus.Size()))
		n3, err := m.ChangeStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.CommittedAt) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.CommittedAt)))
		i += copy(dAtA[i:], m.CommittedAt)
	}
	return i, nil
}

func (m *Gist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gist) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.ForksUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.ForksUrl)))
		i += copy(dAtA[i:], m.ForksUrl)
	}
	if len(m.CommitsUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.CommitsUrl)))
		i += copy(dAtA[i:], m.CommitsUrl)
	}
	if m.Id != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.Id))
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Public {
		dAtA[i] = 0x30
		i++
		if m.Public {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Owner != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.Owner.Size()))
		n4, err := m.Owner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.User != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.User.Size()))
		n5, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Files) > 0 {
		for k, _ := range m.Files {
			dAtA[i] = 0x4a
			i++
			v := m.Files[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGistEvent(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovGistEvent(uint64(len(k))) + msgSize
			i = encodeVarintGistEvent(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintGistEvent(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGistEvent(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if m.Truncated {
		dAtA[i] = 0x50
		i++
		if m.Truncated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Comments != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.Comments))
	}
	if len(m.CommentsUrl) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.CommentsUrl)))
		i += copy(dAtA[i:], m.CommentsUrl)
	}
	if len(m.HtmlUrl) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.HtmlUrl)))
		i += copy(dAtA[i:], m.HtmlUrl)
	}
	if len(m.GitPullUrl) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.GitPullUrl)))
		i += copy(dAtA[i:], m.GitPullUrl)
	}
	if len(m.GitPushUrl) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.GitPushUrl)))
		i += copy(dAtA[i:], m.GitPushUrl)
	}
	if len(m.CreatedAt) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.CreatedAt)))
		i += copy(dAtA[i:], m.CreatedAt)
	}
	if len(m.UpdatedAt) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.UpdatedAt)))
		i += copy(dAtA[i:], m.UpdatedAt)
	}
	if len(m.Forks) > 0 {
		for _, msg := range m.Forks {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintGistEvent(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GistEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GistEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Action) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if m.Gist != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.Gist.Size()))
		n7, err := m.Gist.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Installation != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGistEvent(dAtA, i, uint64(m.Installation.Size()))
		n8, err := m.Installation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func encodeFixed64GistEvent(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32GistEvent(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGistEvent(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GistFile) Size() (n int) {
	var l int
	_ = l
	if m.FileSize != 0 {
		n += 1 + sovGistEvent(uint64(m.FileSize))
	}
	l = len(m.RawUrl)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	if m.Truncated {
		n += 2
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	return n
}

func (m *GistFork) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	return n
}

func (m *GistChangeStatus) Size() (n int) {
	var l int
	_ = l
	if m.Deletions != 0 {
		n += 1 + sovGistEvent(uint64(m.Deletions))
	}
	if m.Additions != 0 {
		n += 1 + sovGistEvent(uint64(m.Additions))
	}
	if m.Total != 0 {
		n += 1 + sovGistEvent(uint64(m.Total))
	}
	return n
}

func (m *GistHistory) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovGistEvent(uint64(l))
	}
	if m.ChangeStatus != nil {
		l = m.ChangeStatus.Size()
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.CommittedAt)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	return n
}

func (m *Gist) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.ForksUrl)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.CommitsUrl)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovGistEvent(uint64(m.Id))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	if m.Public {
		n += 2
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 1 + l + sovGistEvent(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovGistEvent(uint64(l))
	}
	if len(m.Files) > 0 {
		for k, v := range m.Files {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGistEvent(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGistEvent(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGistEvent(uint64(mapEntrySize))
		}
	}
	if m.Truncated {
		n += 2
	}
	if m.Comments != 0 {
		n += 1 + sovGistEvent(uint64(m.Comments))
	}
	l = len(m.CommentsUrl)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.HtmlUrl)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.GitPullUrl)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.GitPushUrl)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 2 + l + sovGistEvent(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 2 + l + sovGistEvent(uint64(l))
	}
	if len(m.Forks) > 0 {
		for _, e := range m.Forks {
			l = e.Size()
			n += 2 + l + sovGistEvent(uint64(l))
		}
	}
	return n
}

func (m *GistEvent) Size() (n int) {
	var l int
	_ = l
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovGistEvent(uint64(l))
	}
	if m.Gist != nil {
		l = m.Gist.Size()
		n += 1 + l + sovGistEvent(uint64(l))
	}
	if m.Installation != nil {
		l = m.Installation.Size()
		n += 1 + l + sovGistEvent(uint64(l))
	}
	return n
}

func sovGistEvent(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGistEvent(x uint64) (n int) {
	return sovGistEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GistFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGistEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GistFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GistFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Truncated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Truncated = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGistEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGistEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GistFork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGistEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GistFork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GistFork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGistEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGistEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GistChangeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGistEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GistChangeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GistChangeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deletions", wireType)
			}
			m.Deletions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deletions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Additions", wireType)
			}
			m.Additions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Additions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGistEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGistEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GistHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGistEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GistHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GistHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeStatus == nil {
				m.ChangeStatus = &GistChangeStatus{}
			}
			if err := m.ChangeStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommittedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGistEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGistEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGistEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForksUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForksUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitsUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitsUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Public = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &User{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Files == nil {
				m.Files = make(map[string]*GistFile)
			}
			var mapkey string
			var mapvalue *GistFile
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGistEvent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGistEvent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGistEvent
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGistEvent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGistEvent
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthGistEvent
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GistFile{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGistEvent(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGistEvent
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Files[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Truncated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Truncated = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			m.Comments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Comments |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentsUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommentsUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HtmlUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HtmlUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitPullUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitPullUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitPushUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitPushUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Forks = append(m.Forks, &GistFork{})
			if err := m.Forks[len(m.Forks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGistEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGistEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GistEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGistEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GistEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GistEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gist == nil {
				m.Gist = &Gist{}
			}
			if err := m.Gist.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Installation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGistEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Installation == nil {
				m.Installation = &Installation{}
			}
			if err := m.Installation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGistEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGistEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGistEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGistEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGistEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGistEvent
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGistEvent
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGistEvent(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGistEvent = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGistEvent   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("gist_event.proto", fileDescriptorGistEvent) }

var fileDescriptorGistEvent = []byte{
	// 741 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xcd, 0x6e, 0xda, 0x4a,
	0x14, 0x8e, 0x01, 0x83, 0x39, 0x38, 0xb9, 0xdc, 0x51, 0x74, 0xe3, 0xcb, 0xbd, 0x97, 0x70, 0x59,
	0x54, 0x6c, 0x42, 0xa4, 0x74, 0x13, 0x55, 0xea, 0x22, 0xa9, 0xd2, 0xbf, 0x55, 0xe5, 0x28, 0x6b,
	0x64, 0xec, 0x89, 0x19, 0x31, 0xd8, 0x68, 0x66, 0x9c, 0x88, 0x6c, 0xba, 0xe8, 0xb6, 0x0f, 0xd0,
	0x97, 0xe8, 0x23, 0x74, 0x9f, 0x65, 0x9f, 0xa0, 0x6a, 0xe9, 0x8b, 0x54, 0x67, 0xc6, 0x06, 0x83,
	0x92, 0xae, 0x98, 0xf3, 0x7d, 0x87, 0xe3, 0xef, 0x7c, 0x73, 0xce, 0x40, 0x3b, 0x66, 0x52, 0x8d,
	0xe8, 0x0d, 0x4d, 0xd4, 0x70, 0x2e, 0x52, 0x95, 0x92, 0x7a, 0xcc, 0xd4, 0x24, 0x1b, 0x77, 0x8e,
	0xcc, 0xef, 0x30, 0x4c, 0x67, 0xc7, 0x71, 0x1a, 0xa7, 0xc7, 0x9a, 0x1e, 0x67, 0xd7, 0x3a, 0xd2,
	0x81, 0x3e, 0x99, 0xbf, 0x75, 0x20, 0x93, 0x54, 0xe4, 0x67, 0xc2, 0x12, 0xa9, 0x02, 0xce, 0x03,
	0xc5, 0xd2, 0xc4, 0x60, 0xfd, 0xcf, 0x16, 0x38, 0xaf, 0x98, 0x54, 0x2f, 0x19, 0xa7, 0xa4, 0x07,
	0x35, 0xc9, 0xee, 0xa8, 0x67, 0xf5, 0xac, 0x81, 0x7d, 0xee, 0x2e, 0xbf, 0x1d, 0x3a, 0x88, 0x5f,
	0xb2, 0x3b, 0xea, 0x6b, 0x86, 0x1c, 0x40, 0x43, 0x04, 0xb7, 0xa3, 0x4c, 0x70, 0xaf, 0xd2, 0xb3,
	0x06, 0x4d, 0xbf, 0x2e, 0x82, 0xdb, 0x2b, 0xc1, 0x09, 0x81, 0x9a, 0x5a, 0xcc, 0xa9, 0x57, 0xd5,
	0xa8, 0x3e, 0x93, 0x0e, 0x38, 0x3c, 0x48, 0xe2, 0x2c, 0x88, 0xa9, 0x57, 0xd3, 0xf8, 0x2a, 0x26,
	0xff, 0x42, 0x53, 0x89, 0x2c, 0x09, 0x03, 0x45, 0x23, 0xcf, 0xee, 0x59, 0x03, 0xc7, 0x5f, 0x03,
	0xc4, 0x83, 0x46, 0x98, 0x26, 0x8a, 0x26, 0xca, 0xab, 0xeb, 0x3f, 0x16, 0x61, 0xff, 0x63, 0xa1,
	0x37, 0x15, 0x53, 0xd4, 0x8b, 0xed, 0x69, 0xbd, 0xad, 0x13, 0x77, 0x98, 0x5b, 0x73, 0x25, 0xa9,
	0xf0, 0x35, 0x43, 0xda, 0x50, 0x5d, 0x6b, 0xc5, 0x23, 0xd9, 0x83, 0x0a, 0x8b, 0x72, 0x99, 0x15,
	0x16, 0x91, 0xff, 0x00, 0x42, 0x41, 0xf1, 0xab, 0xa3, 0x40, 0xe5, 0x32, 0x9b, 0x39, 0x72, 0xa6,
	0x90, 0xce, 0xe6, 0x51, 0x41, 0xdb, 0x86, 0xce, 0x91, 0x33, 0xd5, 0x8f, 0xa0, 0x8d, 0x6a, 0x5e,
	0x4c, 0x82, 0x24, 0xa6, 0x97, 0x2a, 0x50, 0x99, 0xc4, 0xd6, 0x22, 0xca, 0x29, 0x9a, 0x2c, 0x8d,
	0x95, 0xfe, 0x1a, 0x40, 0x36, 0x88, 0x22, 0x66, 0xd8, 0x8a, 0x61, 0x57, 0x00, 0xd9, 0x07, 0x5b,
	0xa5, 0x2a, 0xe0, 0x5a, 0xa0, 0xed, 0x9b, 0xa0, 0xff, 0xc5, 0x82, 0x16, 0x7e, 0xe6, 0x35, 0x93,
	0x2a, 0x15, 0x8b, 0xa2, 0x2b, 0x6b, 0xdd, 0x95, 0x07, 0x8d, 0x1b, 0x2a, 0x24, 0x4b, 0x93, 0xbc,
	0xd7, 0x22, 0x5c, 0x79, 0x54, 0x7d, 0xd4, 0xa3, 0xe7, 0xb0, 0x1b, 0x6a, 0xfd, 0x23, 0xa9, 0x1b,
	0xd0, 0x26, 0xb4, 0x4e, 0xbc, 0x22, 0x75, 0xbb, 0x41, 0xdf, 0x0d, 0xcb, 0xed, 0xfe, 0x0f, 0x6e,
	0x98, 0xce, 0x66, 0x4c, 0x6d, 0x78, 0xd4, 0x5a, 0x61, 0x67, 0xaa, 0xff, 0xc1, 0x86, 0x1a, 0x56,
	0x79, 0x40, 0xf8, 0x3f, 0xd0, 0xbc, 0x4e, 0xc5, 0x54, 0x96, 0x46, 0xca, 0xd1, 0x00, 0x0e, 0xd5,
	0x21, 0xe4, 0x65, 0x0c, 0x6d, 0x2e, 0x0d, 0x72, 0xe8, 0x6a, 0x75, 0x99, 0x35, 0xed, 0x15, 0x5e,
	0x66, 0x0f, 0x5a, 0x11, 0x95, 0xa1, 0x60, 0x73, 0xb4, 0xb3, 0x90, 0x52, 0x82, 0xc8, 0x5f, 0x50,
	0x9f, 0x67, 0x63, 0xce, 0x42, 0x3d, 0x58, 0x8e, 0x9f, 0x47, 0xa4, 0x0f, 0x76, 0x7a, 0x9b, 0x50,
	0xe1, 0x35, 0x1e, 0xf0, 0xc9, 0x50, 0x2b, 0x2b, 0x9d, 0x47, 0xad, 0x3c, 0x02, 0xfb, 0x9a, 0x71,
	0x2a, 0xbd, 0x66, 0xaf, 0x3a, 0x68, 0x9d, 0x1c, 0x94, 0x2d, 0x1c, 0xe2, 0x2a, 0xc9, 0x8b, 0x44,
	0x89, 0x85, 0x6f, 0xb2, 0x36, 0x97, 0x00, 0xb6, 0x97, 0xa0, 0x03, 0x0e, 0xb6, 0x4a, 0x13, 0x25,
	0xbd, 0x96, 0x6e, 0x71, 0x15, 0x17, 0xa6, 0xe3, 0x59, 0x5b, 0xe3, 0xae, 0x4d, 0x47, 0x0c, 0xbd,
	0xf9, 0x1b, 0x9c, 0x89, 0x9a, 0x71, 0x4d, 0xef, 0x9a, 0x99, 0xc0, 0x18, 0xa9, 0x1e, 0xb8, 0x31,
	0x53, 0xa3, 0x79, 0xc6, 0x0d, 0xbd, 0x67, 0x8c, 0x8d, 0x99, 0x7a, 0x97, 0xf1, 0xcd, 0x0c, 0x39,
	0xd1, 0x19, 0x7f, 0x94, 0x32, 0xe4, 0x04, 0x33, 0x36, 0xf7, 0xa6, 0xfd, 0xfb, 0xbd, 0xf9, 0x73,
	0x6b, 0x6f, 0xc8, 0x13, 0xb0, 0xf5, 0x2d, 0x7b, 0x44, 0x1b, 0xd5, 0x2e, 0x1b, 0x85, 0xab, 0xed,
	0x1b, 0xba, 0xf3, 0x16, 0x60, 0x6d, 0x1b, 0x8e, 0xcf, 0x94, 0x2e, 0x8a, 0xf1, 0x99, 0xd2, 0x05,
	0xd6, 0xb9, 0x09, 0x78, 0x46, 0xf5, 0xe8, 0x6c, 0xd7, 0x61, 0x9c, 0xfa, 0x86, 0x7e, 0x56, 0x39,
	0xb5, 0xfa, 0xef, 0xa1, 0x89, 0xf0, 0x05, 0x3e, 0xaa, 0x38, 0x07, 0x41, 0xa8, 0x87, 0xc4, 0x54,
	0xcb, 0x23, 0xbc, 0x63, 0x7c, 0x7a, 0xf3, 0x7a, 0x6e, 0xb9, 0x9e, 0xaf, 0x19, 0x72, 0x0a, 0x6e,
	0xf9, 0x1d, 0xcd, 0x17, 0x6b, 0xbf, 0xc8, 0x7c, 0x53, 0xe2, 0xfc, 0x8d, 0xcc, 0xf3, 0xfd, 0xfb,
	0x1f, 0xdd, 0x9d, 0xfb, 0x65, 0xd7, 0xfa, 0xba, 0xec, 0x5a, 0xdf, 0x97, 0x5d, 0xeb, 0xd3, 0xcf,
	0xee, 0xce, 0xb8, 0xae, 0x1f, 0xe2, 0xa7, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x63, 0xd2, 0xc7,
	0x9d, 0xf3, 0x05, 0x00, 0x00,
}
